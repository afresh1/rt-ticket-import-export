#!/usr/bin/perl -w
#
# This script outputs all reminders that are due within the next e.g. two
# days and mails the result to the corresponding owners.
#
package RT::Importer;

#use lib ("/etc/request-tracker3.6", "/usr/lib/rt/",
#		 "/usr/local/share/request-tracker3.6/lib");
use lib (
    "/etc/request-tracker3.6",
    "/usr/share/request-tracker3.6/lib",
    "/usr/local/share/request-tracker3.6/lib"
);

use RT::Interface::CLI qw(CleanEnv GetCurrentUser);
use RT::Ticket;
use RT::User;
use RT::Attachment;
use RT::Transaction;
use MIME::Base64;

use Data::Dumper;

use XML::Simple;

use strict;

use Getopt::Std;

my %opts;
getopts( 'c:r:d:h', \%opts );

my $cf        = $opts{'c'};
my $rtname    = $opts{'r'};
my $directory = $opts{'d'};

unless ( !$opts{'h'} && $cf && $rtname && $directory ) {
    print
        "rt-ticket-importer -d <directory> -r <source RT name> -c <CustomfieldId>\n";
    exit;
}

my %user_types = map { $_ => 1 } qw(
    Owner
    Creator
    LastUpdatedBy
    Requestor
    Cc
    AdminCc
    AddWatcher
    DelWatcher
    Take
);

my %link_types = map { $_ => 1 } qw(
    DependsOn
    DependedOnBy
    RefersTo
    ReferredToBy
    MemberOf
    MergedInto
    HasMember
);

# clean out all the nasties from the environment..
CleanEnv();

# load the config file..
RT::LoadConfig();

# connect to the database and get RT::SystemUser and RT::Nobody loaded..
RT::Init();

# reset the RT die signal handler, we don't need the extra info..
$SIG{__DIE__} = "";

# drop setgid permissions, which is version 3.0 specific
eval { RT::DropSetGIDPermissions() };

my %USERS;
my %QUEUES;
my %TICKETS;
my %TRANSACTIONS;
my %LINKS;
my %ATTACHMENTS;

sub ConvertUser {
    my $user = shift;
    return $RT::Nobody->Id unless ($user);
    return $USERS{$user} if ( $USERS{$user} );
    my $userObj = new RT::User($RT::SystemUser);
    $userObj->LoadOrCreateByEmail($user);
    $USERS{$user} = $userObj->Id;
    return $USERS{$user};
}

sub ConvertQueue {
    my ($queue) = @_;
    return $QUEUES{$queue} if $QUEUES{$queue};
    my $queueObj = new RT::Queue($RT::SystemUser);
    $queueObj->Load($queue);
    return $QUEUES{$queue} = $queueObj->Id || ConvertQueue('General');
}

sub _ConvertItem {
    my $type = shift;
    my $item = shift;

    my %T = (
        Tickets => {
            import   => \&import_ticket,
            children => 'Transactions',
        },
        Transactions => {
            import    => \&import_transaction,
            children  => 'Attachments',
            parent_id => 'ObjectId',
        },
        Attachments => {
            import    => \&import_attachment,
            parent_id => 'TransactionId',
        },
        Links => { import => \&import_link, }
    );

    die "Unknown type [$type]!" unless $T{$type};

    my $old_id = $item->{id};
    my $new_id = $E{$type}{$old_id} || $T{$type}{import}( $item, @_ );
    if ($new_id) {
        $E{$type}{$old_id} = $new_id;
        print "Created $type #$old_id\n";
    }
    else {

        # Get rid of the old id to try to create with a new id
        delete $item->{id};
        $new_id = $T{$type}{import}( $item, @_ );
        $E{$type}{$old_id} = $new_id;
        print "Created $type #$old_id as #$new_id\n";
    }
    unless ( $E{$type}{$old_id} ) {
        print STDERR "Failed to create $type $old_id!!!\n";
        return;
    }

    my $child_type = $T{$type}{children};
    if ( $child_type and $item->{$child_type} ) {
        my $parent_id = $T{$child_type}{parent_id};
        foreach my $child_id (
            sort { $a <=> $b }
            keys %{ $item->{$child_type} }
            )
        {
            my $child = $item->{$child_type}->{$child_id};
            $child->{$parent_id} = $new_id if $parent_id;
            _ConvertItem( $child_type, $child, $new_id );
        }
    }

    return $new_id;
}

sub ConvertTicket      { _ConvertItem( 'Tickets',      @_ ) }
sub ConvertTransaction { _ConvertItem( 'Transactions', @_ ) }
sub ConvertAttachment  { _ConvertItem( 'Attachments',  @_ ) }
sub ConvertLink        { _ConvertItem( 'Links',        @_ ) }


    $ticketObj->SetEffectiveId( ConvertTicket($eid) ) if ( $eid != $id );
    $ticketObj->{'_AccessibleCache'}{Created}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $ticketObj->{'_AccessibleCache'}{Creator}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $ticketObj->{'_AccessibleCache'}{LastUpdated}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $ticketObj->{'_AccessibleCache'}{LastUpdatedBy}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $ticketObj->SetCreated( $ticket->{'Created'} );
    $ticketObj->SetCreator( $ticket->{'Creator'} );
    $ticketObj->SetLastUpdated( $ticket->{'LastUpdated'} );
    $ticketObj->SetLastUpdatedBy( $ticket->{'LastUpdatedBy'} );

    $ticketObj->AddCustomFieldValue(
        Field => $cf,
        Value => "[$rtname #$id]"
    );

    $TICKETS{$id} = $newid;
    return $newid;
}

sub ConvertTransaction {

    my $id = shift;

    return $TRANSACTIONS{$id} if ( $TRANSACTIONS{$id} );

    my $transaction = $transactions->{$id};

    my $transactionObj = new RT::Transaction($RT::SystemUser);

    foreach my $key ( keys %$transaction ) {
        $transaction->{$key} = undef if ( ref( $transaction->{$key} ) );
    }

    # We're cheating and only importing Ticket Transactions
    $transaction->{'ObjectId'} = ConvertTicket( $transaction->{'ObjectId'} );
    $transaction->{'Creator'}  = ConvertUser( $transaction->{'Creator'} );
    return undef unless ( defined( $transaction->{'ObjectId'} ) );

    if (   ( $transaction->{'Type'} eq 'Owner' )
        || ( $transaction->{'Type'} eq 'Requestor' )
        || ( $transaction->{'Type'} eq 'Cc' )
        || ( $transaction->{'Type'} eq 'AdminCc' ) )
    {
        $transaction->{'OldValue'}
            = ConvertUser( $transaction->{'OldValue'} );
        $transaction->{'NewValue'}
            = ConvertUser( $transaction->{'NewValue'} );
    }

    if (   ( $transaction->{'Type'} eq 'DependsOn' )
        || ( $transaction->{'Type'} eq 'DependedOnBy' )
        || ( $transaction->{'Type'} eq 'RefersTo' )
        || ( $transaction->{'Type'} eq 'ReferredToBy' )
        || ( $transaction->{'Type'} eq 'MemberOf' )
        || ( $transaction->{'Type'} eq 'MergedInto' )
        || ( $transaction->{'Type'} eq 'HasMember' ) )
    {
        $transaction->{'OldValue'}
            = ConvertTicket( $transaction->{'OldValue'} );
        $transaction->{'NewValue'}
            = ConvertTicket( $transaction->{'NewValue'} );
    }

    $transaction->{'ActivateScrips'} = 0;

    my ( $newid, $msg ) = $transactionObj->Create(%$transaction);

    unless ($newid) {
        print STDERR "Failed to create Transaction $id ($msg)!!!\n";
        return undef;
    }

    print "Created Transaction # $id : as # $newid\n";
    $| = 1;
    $transactionObj->{'_AccessibleCache'}{Created}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $transactionObj->{'_AccessibleCache'}{Creator}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $transactionObj->SetCreated( $transaction->{'Created'} );
    $transactionObj->SetCreator( $transaction->{'Creator'} );

    $TRANSACTIONS{$id} = $newid;
    return $newid;
}

sub ConvertAttachment {
    my $id = shift;

    return $ATTACHMENTS{$id} if ( $ATTACHMENTS{$id} );
    my $attachment = $attachments->{$id};

    foreach my $key ( keys %$attachment ) {
        $attachment->{$key} = undef if ( ref( $attachment->{$key} ) );
    }

    if ( $attachment->{'Parent'} ) {
        my $parent = $attachment->{'Parent'};
        $attachment->{'Parent'} = ConvertAttachment($parent);
    }

    my $attachObj = new RT::Attachment($RT::SystemUser);

    $attachment->{'Creator'} = ConvertUser( $attachment->{'Creator'} );

    $attachment->{'TransactionId'}
        = ConvertTransaction( $attachment->{'TransactionId'} );
    return undef unless ( defined( $attachment->{'TransactionId'} ) );

    Encode::_utf8_off( $attachment->{'Content'} );
    $attachment->{'Content'} = decode_base64( $attachment->{'Content'} );

    my ( $newid, $msg ) = $attachObj->Import(%$attachment);

    unless ($newid) {
        print STDERR "Failed to create Attachment $id ($msg)!!!\n";
        return undef;
    }

    print "Created Attachment # $id : as # $newid\n";
    $| = 1;
    $attachObj->{'_AccessibleCache'}{Created}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $attachObj->{'_AccessibleCache'}{Creator}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $attachObj->SetCreated( $attachment->{'Created'} );
    $attachObj->SetCreator( $attachment->{'Creator'} );
    $ATTACHMENTS{$id} = $newid;
    return $newid;

}

sub ConvertLink {
    my $id = shift;

    return $LINKS{$id} if ( $LINKS{$id} );

    my $link    = $links->{$id};
    my $linkObj = new RT::Link($RT::SystemUser);

    my $base = $link->{'Base'};
    $base =~ /([0-9]*)$/;
    $base = $1;
    my $target = $link->{'Target'};
    $target =~ /([0-9]*)$/;
    $target = $1;

    my $newid = $linkObj->Create(
        Base   => ConvertTicket($base),
        Target => ConvertTicket($target),
        Type   => $link->{'Type'}
    );

    if ( $newid == 0 ) {
        print STDERR "Failed to create Link $id!!!\n";
        return undef;
    }

    print "Created Link # $id : as # $newid\n";
    $| = 1;
    $LINKS{$id} = $newid;
    $linkObj->{'_AccessibleCache'}{Created}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $linkObj->{'_AccessibleCache'}{Creator}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $linkObj->{'_AccessibleCache'}{LastUpdated}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $linkObj->{'_AccessibleCache'}{LastUpdatedBy}
        = { 'read' => 1, 'write' => 1, 'auto' => 0 };
    $linkObj->SetCreated( $link->{'Created'} );
    $linkObj->SetCreator( ConvertUser( $link->{'Creator'} ) );
    $linkObj->SetLastUpdated( $link->{'LastUpdated'} );
    $linkObj->SetLastUpdatedBy( $link->{'LastUpdatedBy'} );

    return $newid;

}

opendir my $dh, $directory or die $!;
my @files = map {"$directory/$_"}
    sort grep { $_ =~ /Ticket_\d+\.xml$/i } readdir $dh;
closedir $dh;

foreach my $file (@files) {
    warn "Converting $file\n";
    my $ticket = XMLin(
        $file,
        SuppressEmpty => 1,
        GroupTags     => {
            Transactions => 'Transaction',
            Attachments  => 'Attachment',
            CustomFields => 'CustomField',
        },
        ForceArray => [qw( Transaction Attachment CustomField )],
        KeyAttr    => { Transaction => '+id', Attachment => '+id' },
    );
    ConvertTicket($ticket);
}

process_queued_links();
